<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Gwern.net-Inspired Page with Side Notes</title>
    <style>

    </style>
    <link type="text/css" rel="stylesheet" href="css/gwern.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>

</head>

<body>
    <div id="dark-mode-toggle" title="Toggle Dark Mode">
        L/D
    </div>
    <!-- Floating window for Wikipedia content -->
    <div id="floating-window" style="display: none;">
        <div id="floating-header">
            <span id="window-title">Wikipedia</span>
            <button id="close-button">X</button>
        </div>
        <div id="wiki-content"></div>
    </div>
    <div class="bodyArticle">
        <div class="articleContainer">
            <div class="left-column">
                <!-- Empty left column -->
            </div>

            <div class="center-column">
                <h1>Analyzing Anonymity in *Death Note*</h1>

                <img class="articleImage" src="docs/test.webp" alt="Paris" >


                <p>How many times were you frustrated while looking
                    out for a good collection of programming/algorithm
                    /interview questions? What did you expect and what
                    did you get? This portal has been created to
                    provide well written, well thought and well
                    explained solutions for selected questions.
                    An IIT Roorkee alumnus and founder of GeeksforGeeks.
                    He loves to solve programming problems in most
                    efficient ways. Apart from GeeksforGeeks, he has
                    worked with DE Shaw and Co. as a software developer
                    and JIIT Noida as an assistant professor. It is a
                    good platform to learn programming. It is an
                    educational website. Prepare for the Recruitment
                    drive of product based companies like Microsoft,
                    Amazon, Adobe etc with a free online placement
                    preparation course.
                </p>

                <h2>Understanding Light's Mistakes</h2>
                <p class="reference" data-ref="1">One fundamental error that <a class="wiki-link"
                        data-term="Light_Yagami">Light
                        Yagami</a> made was failing to control the timing of his murders, creating patterns that helped
                    L
                    deduce the time zone and location.</p>

                

                <blockquote class="reference" data-ref="2">
                    "If you change the world in even the slightest way, you leak information about yourself."
                </blockquote>

                <p>Another critical mistake occurred when he killed FBI agent Ray Penbar, effectively narrowing down the
                    suspect pool. L leveraged information theory principles to analyze each event as a data point,
                    reducing
                    Light's anonymity bit by bit.</p>

                <h2>Applying Information Theory</h2>
                <p>Lâ€™s investigation was a search problem, starting with a large pool of suspects and methodically
                    narrowing
                    it down. By observing patterns, L reduced the suspect pool from billions of people to one prime
                    suspect.
                </p>

                <p>This process showcases how anonymity can be incrementally compromised. A <a
                        href="javascript:void(0);" class="wiki-link" data-term="De-anonymization">de-anonymization
                        technique</a> based on behavior
                    patterns could apply similarly in real-world data privacy contexts.</p>

                <div class="footnote" id="footnote1">
                    <p><sup>1</sup> Light's scheduling of deaths provided clues for L to infer his nationality and
                        timezone.
                    </p>
                </div>

                <div class="footnote" id="footnote2">
                    <p><sup>2</sup> De-anonymization can occur through consistent behavior, as seen when Light continued
                        using the Death Note in predictable ways.</p>
                </div>
            </div>

            <div class="right-column">
                <!-- Dynamic Side Notes -->
                <div id="side-note-1" class="side-note">
                    <p><strong>Side Note 1:</strong> Information leaks from consistent actions, allowing
                        de-anonymization.
                    </p>
                </div>
                <div id="side-note-2" class="side-note">
                    <p><strong>Side Note 2:</strong> De-anonymization relates to real-world privacy risks in digital
                        behavior tracking.</p>
                </div>


            </div>
        </div>
    </div>

    <script>
        const width = 600;
        const radius = width / 2;
        const colorin = "green";
        const colorout = "orange";

        const tree = d3.cluster()
            .size([2 * Math.PI, radius - 100]);

        async function draw() {
            const data = hierarchy(await fetch("flare.json").then(response => response.json()));

            const root = tree(bilink(d3.hierarchy(data)
                .sort((a, b) => d3.ascending(a.height, b.height) || d3.ascending(a.data.name, b.data.name))
            ));

            const svg = d3.select(".left-column")
                .append("svg")
                .attr("width", width)
                .attr("height", width)
                .attr("viewBox", [-width / 2, -width / 2, width, width])
                .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;");



            const node = svg.append("g")
                .selectAll()
                .data(root.leaves())
                .join("g")
                .attr("transform", d => `rotate(${d.x * 180 / Math.PI - 90}) translate(${d.y},0)`);

            node.append("text")
                .attr("dy", "0.31em")
                .attr("x", d => d.x < Math.PI ? 6 : -6)
                .attr("text-anchor", d => d.x < Math.PI ? "start" : "end")
                .attr("transform", d => d.x >= Math.PI ? "rotate(180)" : null)
                .attr("font-size", "0.4em")
                .text(d => d.data.name)
                .on("mouseover", overed)
                .on("mouseout", outed)
                .call(text => text.append("title").text(d => `${id(d)}
    ${d.outgoing.length} outgoing
    ${d.incoming.length} incoming`));

            const link = svg.append("g")
                .attr("stroke", "#ccc")
                .attr("fill", "none")
                .selectAll()
                .data(root.leaves().flatMap(leaf => leaf.outgoing))
                .join("path")
                .attr("d", ([i, o]) => d3.lineRadial()
                    .curve(d3.curveBundle.beta(0.85))
                    .radius(d => d.y)
                    .angle(d => d.x)(i.path(o)));

            function overed(event, d) {
                link.style("mix-blend-mode", null);
                d3.select(this).attr("font-weight", "bold");
                d3.selectAll(d.incoming.map(d => d.path)).attr("stroke", colorin).raise();
                d3.selectAll(d.incoming.map(([d]) => d.text)).attr("fill", colorin).attr("font-weight", "bold");
                d3.selectAll(d.outgoing.map(d => d.path)).attr("stroke", colorout).raise();
                d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("fill", colorout).attr("font-weight", "bold");
            }

            function outed(event, d) {
                link.style("mix-blend-mode", "multiply");
                d3.select(this).attr("font-weight", null);
                d3.selectAll(d.incoming.map(d => d.path)).attr("stroke", null);
                d3.selectAll(d.incoming.map(([d]) => d.text)).attr("fill", null).attr("font-weight", null);
                d3.selectAll(d.outgoing.map(d => d.path)).attr("stroke", null);
                d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("fill", null).attr("font-weight", null);
            }

            function hierarchy(data, delimiter = ".") {
                let root;
                const map = new Map;
                data.forEach(function find(data) {
                    const {
                        name
                    } = data;
                    if (map.has(name)) return map.get(name);
                    const i = name.lastIndexOf(delimiter);
                    map.set(name, data);
                    if (i >= 0) {
                        find({
                            name: name.substring(0, i),
                            children: []
                        }).children.push(data);
                        data.name = name.substring(i + 1);
                    } else {
                        root = data;
                    }
                    return data;
                });
                return root;
            }

            function bilink(root) {
                const map = new Map(root.leaves().map(d => [id(d), d]));
                for (const d of root.leaves()) d.incoming = [], d.outgoing = d.data.imports.map(i => [d, map.get(
                    i)]);
                for (const d of root.leaves())
                    for (const o of d.outgoing) o[1].incoming.push(o);
                return root;
            }

            function id(node) {
                return `${node.parent ? id(node.parent) + "." : ""}${node.data.name}`;
            }
        }

        draw();
    </script>

    <script>
        function updateSideNotes() {
            const references = document.querySelectorAll('.reference');
            references.forEach(ref => {
                const noteId = `side-note-${ref.dataset.ref}`;

                const sideNote = document.getElementById(noteId);
                if (sideNote) {
                    console.log(sideNote)

                    const refPosition = ref.getBoundingClientRect();
                    sideNote.style.top = `${window.scrollY + refPosition.top}px`;
                }
            });
        }

        // Update side notes on load and window resize
        window.addEventListener('load', updateSideNotes);
        window.addEventListener('resize', updateSideNotes);


        function changeColor(color) {

            d3.selectAll("g")
                .transition()
                .duration(2000)
                .style("fill", color)
        }

        const darkModeToggle = document.getElementById('dark-mode-toggle');
        darkModeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            changeColor("white")

        });
    </script>

<script  src="src/wikiSearch.js"></script>
</body>

</html>